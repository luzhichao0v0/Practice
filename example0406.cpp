#include <stdio.h>

/*
	利用2/3查看浮点类型的有效位数

	==>
		1、单精度型(float)变量有效数字为7位，双精度型(double)变量有效数字为16位。
		2、浮点型数据在机内用指数形式表示：符号位(数符、1位)、指数位(指数+指数符)、小数位(尾数)。
		3、指数位决定了取值范围，指数位可以分为有符号和无符号。
			float：8位，0B0111 1111=127，取值范围：2^[-127~128]
			double：11位，0B011 1111 1111=1023，取值范围：2^[-1023~1024]
		4、指数位存储时按无符号整数存储(因为以无符号形式存储，所以128可表示，-128不能表示)。以float为例：
			正数：6 =>6(要存储数)+127(指数位偏移量)=133=>0B1000 0101(存储数)
			负数：-3 =>-3(要存储数)+127(指数位偏移量)=124=>0B01111100(存储数)
		5、小数位决定了精度范围
			float：23位，0B111 1111 1111 1111 1111 1111=8388607，最大表示十进制7位，保证表示十进制6位
			double：52位，0B111 1111 .... 1111=4503599627370495，最大表示十进制16位，保证表示十进制15位
		ps：
			(78.375)
			=(0B0100 1110)+(0.375)
			=0B0100 1110+(3/8)
			=0B0100 1110+(1/4+1/8)
			=0B0100 1110+(2^-2+2^-3)
			=0B0100 1110+(0B0.01+0B0.001)
			=0B0100 1110.011
			=1.001110011x2^6
			78.375 = 0 10000101 001110011 00000 00000 0000
			第一部分用来存储符号位(sign)，用来区分正负，0表示正数
			第二部分用来存储指数(exponent)，这里的指数是十进制的 6
			第三部分用来存储小数(fraction)，这里的小数部分是 001110011
	<==
*/
void example0406()
{
	printf("=====example0406()=====\n");

	float i;
	double j;

	i = 2.0 / 3;
	j = 2.0 / 3;
	
	//i==0.66666668653488159180 有效数字为0+7位(不算0)
	printf("i==%.20f\n", i);
	//0.123456789F=0.12345679104328155518 有效数字为0+7位(不算0)
	printf("0.123456789F=%.20f\n", 0.123456789F);
	//1.123456789F=1.12345683574676513672 有效数字为1+6位
	printf("1.123456789F=%.20f\n", 1.123456789F);

	//21.123456789F=21.12345695495605468750 有效数字为2+6位(×) 小数后第6位刚好是6，属于错误性正确，所以不应该计算位数。
	printf("21.123456789F=%.20f\n", 21.123456789F);
	//21.123457789F=21.12345695495605468750 有效数字为2+5位 验证了小数后第16位为固定6，不应计算该位精度。
	printf("21.123457789F=%.20f\n", 21.123457789F);

	//123.123456789F=123.12345886230468750000 有效数字为3+5位(??????)
	printf("123.123456789F=%.20f\n", 123.123456789F);
	//123.123776789F=123.12377929687500000000 有效数字为3+5位(??????)
	printf("123.123776789F=%.20f\n", 123.123776789F);

	//1234.123456789F=1234.12341308593750000000 有效数字为4+4位(?????) 
	printf("1234.123456789F=%.20f\n", 1234.123456789F);
	//1234.126656789F=1234.12658691406250000000 有效数字为4+3位
	printf("1234.126656789F=%.20f\n", 1234.1266456789F);

	//j==0.66666666666666662966 有效数字为0+16位(不算0)
	printf("j==%.20f\n", j);
	
	//2.12345678901234567890123456789L=2.12345678901234569125 有效数字为1+16位(×) 小数后第16位刚好是6，属于错误性正确，所以不应该计算位数。
	printf("2.12345678901234567890123456789L=%.20f\n", 2.12345678901234567890123456789L);
	//2.12345678901234577890123456789L=2.12345678901234569125 有效数字为1+15位 验证了小数后第16位为固定6，不应计算该位精度。
	printf("2.12345678901234577890123456789L=%.20f\n", 2.12345678901234577890123456789L);

	//12.12345678901234567890123456789L=12.12345678901234613534 有效数字为2+14位
	printf("12.12345678901234567890123456789L=%.20f\n", 12.12345678901234567890123456789L);
	//123.12345678901234567890123456789L=123.12345678901235146441 有效数字为3+13位
	printf("123.12345678901234567890123456789L=%.20f\n", 123.12345678901234567890123456789L);
	//123.98765432109876543210987654321L=123.98765432109875916922 有效数字为3+13位
	printf("123.98765432109876543210987654321L=%.20f\n", 123.98765432109876543210987654321L);
	
}